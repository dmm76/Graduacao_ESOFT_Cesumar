# Expandindo o conteúdo HTML com explicações e exemplos para cada unidade
html_conteudo_expandido = """
<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>Resumo Estrutura de Dados I</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.7;
            margin: 40px;
            background-color: #f4f7fa;
            color: #2a2a2a;
        }
        h1 {
            color: #0c3c78;
        }
        h2 {
            color: #16558f;
            border-bottom: 2px solid #ccc;
            padding-bottom: 5px;
        }
        h3 {
            margin-top: 20px;
            color: #0c3c78;
        }
        ul {
            margin-top: 5px;
            margin-bottom: 20px;
        }
        li {
            margin-bottom: 6px;
        }
        code {
            background-color: #eef;
            padding: 2px 4px;
            font-size: 0.95em;
        }
        .example {
            background: #fff;
            border-left: 4px solid #0c3c78;
            padding: 10px;
            margin: 10px 0;
            font-size: 0.95em;
            font-family: Consolas, monospace;
        }
        .section {
            margin-bottom: 45px;
        }
    </style>
</head>
<body>
    <h1>Resumo Didático – Estrutura de Dados I</h1>

    <div class="section">
        <h2>Unidade 1 – Ponteiros</h2>
        <p>Ponteiros são variáveis que armazenam endereços de memória, permitindo manipular dados indiretamente. Essenciais para estruturas dinâmicas.</p>
        <ul>
            <li><strong>Vetores e Matrizes:</strong> usados para armazenar conjuntos de dados homogêneos.</li>
            <li><strong>Registros (struct):</strong> permitem combinar diferentes tipos de dados.</li>
            <li><strong>Ponteiros:</strong> úteis para manipular dados dinamicamente.</li>
        </ul>
        <div class="example">
            int x = 10;<br>
            int *ptr = &x;<br>
            printf("%d", *ptr); // imprime 10
        </div>
        <p>Alocação dinâmica com <code>malloc()</code> permite reservar espaço na memória em tempo de execução.</p>
        <div class="example">
            int *vetor = (int *) malloc(sizeof(int) * 5);<br>
            vetor[0] = 1;
        </div>
    </div>

    <div class="section">
        <h2>Unidade 2 – Pilhas e Filas</h2>
        <p>Essas estruturas controlam a ordem de inserção e remoção de elementos.</p>
        <ul>
            <li><strong>Pilha (LIFO):</strong> Último a entrar, primeiro a sair.</li>
            <li><strong>Fila (FIFO):</strong> Primeiro a entrar, primeiro a sair.</li>
        </ul>
        <div class="example">
            // Pilha<br>
            push(1); push(2); pop(); // remove o 2<br><br>
            // Fila<br>
            enqueue(1); enqueue(2); dequeue(); // remove o 1
        </div>
    </div>

    <div class="section">
        <h2>Unidade 3 – Listas Dinâmicas</h2>
        <p>Listas são estruturas flexíveis compostas por nós conectados, podendo crescer dinamicamente.</p>
        <ul>
            <li><strong>Encadeada:</strong> cada nó aponta para o próximo.</li>
            <li><strong>Duplamente Encadeada:</strong> cada nó aponta para o próximo e anterior.</li>
            <li><strong>Circular:</strong> o último nó aponta para o primeiro.</li>
        </ul>
        <div class="example">
            struct Node {<br>
            &nbsp;&nbsp;int valor;<br>
            &nbsp;&nbsp;struct Node *prox;<br>
            };
        </div>
    </div>

    <div class="section">
        <h2>Unidade 4 – Grafos</h2>
        <p>Grafos são usados para modelar relacionamentos e conexões entre elementos.</p>
        <ul>
            <li><strong>Vertices:</strong> elementos.</li>
            <li><strong>Arestas:</strong> conexões entre os vértices.</li>
        </ul>
        <p>Representações:</p>
        <ul>
            <li><code>Matriz de adjacência:</code> boa para grafos densos.</li>
            <li><code>Lista de adjacência:</code> eficiente para grafos esparsos.</li>
        </ul>
        <div class="example">
            // Lista de adjacência<br>
            lista[0] -> 1 -> 2<br>
            lista[1] -> 3
        </div>
    </div>

    <div class="section">
        <h2>Unidade 5 – Busca em Grafos</h2>
        <p>Técnicas para explorar ou encontrar caminhos em grafos.</p>
        <ul>
            <li><strong>Busca em Profundidade (DFS):</strong> explora ao máximo antes de retroceder.</li>
            <li><strong>Busca em Largura (BFS):</strong> explora todos os vizinhos primeiro.</li>
            <li><strong>Dijkstra:</strong> encontra o caminho mais curto entre dois nós.</li>
        </ul>
        <div class="example">
            // DFS pseudo-código<br>
            dfs(v):<br>
            &nbsp;&nbsp;marca v como visitado<br>
            &nbsp;&nbsp;para cada vizinho u de v:<br>
            &nbsp;&nbsp;&nbsp;&nbsp;se u não visitado, dfs(u)
        </div>
    </div>

    <div class="section">
        <h2>Conclusão</h2>
        <p>O domínio de estruturas de dados permite resolver problemas de forma eficiente, economizando memória e tempo de execução. Este livro oferece a base para aplicar esses conceitos em algoritmos reais e sistemas mais complexos.</p>
    </div>
</body>
</html>
"""

# Salvar o HTML com explicações e exemplos
html_expandido_path = "/mnt/data/Resumo_Estrutura_de_Dados_Explicado.html"
with open(html_expandido_path, "w", encoding="utf-8") as f:
    f.write(html_conteudo_expandido)

html_expandido_path
