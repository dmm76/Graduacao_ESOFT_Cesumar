
<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>Resumo Estrutura de Dados I - Completo</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; background: #fff; color: #333; }
        h1, h2 { color: #004080; }
        h2 { border-bottom: 2px solid #004080; padding-bottom: 6px; margin-top: 50px; }
        pre { background: #f4f4f4; padding: 15px; border-left: 4px solid #004080; white-space: pre-wrap; overflow-x: auto; }
        nav a { display: block; margin: 5px 0; color: #0077cc; text-decoration: none; }
        nav a:hover { text-decoration: underline; }
    </style>
</head>
<body>
    <h1>Resumo Estrutura de Dados I ‚Äì Completo</h1>
    <nav>
<a href="#unidade1">Unidade 1 ‚Äì Ponteiros</a>
<a href="#unidade2">Unidade 2 ‚Äì Pilhas e Filas</a>
<a href="#unidade3">Unidade 3 ‚Äì Listas Din√¢micas</a>
<a href="#unidade4">Unidade 4 ‚Äì Grafos</a>
<a href="#unidade5">Unidade 5 ‚Äì Busca em Grafos</a>
</nav>
<h2 id="unidade1">Unidade 1 ‚Äì Ponteiros</h2>
<pre>üìÑ O conte√∫do desta unidade est√° no PDF: <a href='Resumo_Unidade1_Completo.pdf' target='_blank'>Resumo_Unidade1_Completo.pdf</a></pre>
<h2 id="unidade2">Unidade 2 ‚Äì Pilhas e Filas</h2>
<pre>Resumo ‚Äì Unidade 2: Pilhas e Filas

1. Conceitos Iniciais

Pilhas e filas s√£o estruturas de dados do tipo est√°tico, constru√≠das geralmente com vetores.
A principal diferen√ßa entre elas est√° na forma como os elementos s√£o inseridos e removidos:

- Pilha: estrutura LIFO (Last In, First Out) ‚Äì √∫ltimo a entrar √© o primeiro a sair.
- Fila: estrutura FIFO (First In, First Out) ‚Äì primeiro a entrar √© o primeiro a sair.

2. Pilhas

A pilha funciona como uma pilha de pratos: o √∫ltimo prato colocado no topo √© o primeiro a ser retirado.

Declara√ß√£o da estrutura em C:
#define TAM 10
struct Pilha {
    int dados[TAM];
    int topo;
};

Opera√ß√µes principais:
- push: empilhar um novo elemento
- pop: desempilhar o elemento do topo

Exemplo de empilhamento:
void push(struct Pilha *p, int valor) {
    if (p->topo == TAM) {
        printf("Pilha cheia!\n");
        return;
    }
    p->dados[p->topo] = valor;
    p->topo++;
}

Exemplo de desempilhamento:
int pop(struct Pilha *p) {
    if (p->topo == 0) {
        printf("Pilha vazia!\n");
        return -1;
    }
    p->topo--;
    return p->dados[p->topo];
}

3. Filas

A fila √© como uma fila de banco: quem chega primeiro √© atendido primeiro.

Declara√ß√£o da estrutura em C:
#define TAM 10
struct Fila {
    int dados[TAM];
    int ini;
    int fim;
};

Opera√ß√µes principais:
- enqueue: inserir no final (fim)
- dequeue: remover do in√≠cio (ini)

Exemplo de inser√ß√£o na fila:
void enqueue(struct Fila *f, int valor) {
    if (f->fim == TAM) {
        printf("Fila cheia!\n");
        return;
    }
    f->dados[f->fim] = valor;
    f->fim++;
}

Exemplo de remo√ß√£o:
int dequeue(struct Fila *f) {
    if (f->ini == f->fim) {
        printf("Fila vazia!\n");
        return -1;
    }
    int valor = f->dados[f->ini];
    f->ini++;
    return valor;
}

Observa√ß√£o: a fila "consome" espa√ßo ao longo do tempo, pois o √≠ndice inicial avan√ßa.
Em implementa√ß√µes mais robustas, usamos filas circulares para aproveitar melhor o espa√ßo.

4. Compara√ß√£o entre Pilha e Fila:

| Estrutura | Inser√ß√£o | Remo√ß√£o |
|-----------|----------|---------|
| Pilha     | Topo     | Topo    |
| Fila      | Final    | In√≠cio  |

---

QUEST√ïES FREQUENTES (ESTILO PROVA)

1. O que √© uma pilha?
- Uma estrutura de dados do tipo LIFO, onde o √∫ltimo elemento inserido √© o primeiro a ser removido.

2. Qual fun√ß√£o realiza a remo√ß√£o de elementos na pilha?
- pop()

3. Como funciona a inser√ß√£o em uma fila?
- Inser√ß√£o ocorre no final, remo√ß√£o no in√≠cio (estrutura FIFO).

4. O que acontece ao remover um item de uma fila vazia?
- O programa deve acusar erro ou retornar valor inv√°lido.

5. Para que serve a constante TAM?
- Define o tamanho m√°ximo da estrutura (pilha ou fila).

6. Como evitar estouro de pilha ou fila?
- Usando verifica√ß√µes antes da inser√ß√£o ou remo√ß√£o.

7. O que acontece se n√£o controlar o avan√ßo do √≠ndice em uma fila?
- A fila pode parecer cheia mesmo havendo espa√ßo livre no in√≠cio.</pre>
<h2 id="unidade3">Unidade 3 ‚Äì Listas Din√¢micas</h2>
<pre>Resumo ‚Äì Unidade 3: Listas Din√¢micas

1. Introdu√ß√£o

Listas din√¢micas s√£o estruturas de dados que permitem armazenar elementos de forma n√£o cont√≠gua na mem√≥ria, usando ponteiros.
Diferente dos vetores, que precisam de tamanho fixo, listas din√¢micas se adaptam conforme a necessidade de inser√ß√£o e remo√ß√£o de dados.

2. Lista Encadeada Simples

Cada elemento (n√≥) armazena um valor e um ponteiro para o pr√≥ximo n√≥. A lista termina quando o ponteiro for NULL.

Exemplo da estrutura em C:
struct No {
    int valor;
    struct No* prox;
};

Fun√ß√£o para inserir no in√≠cio:
struct No* inserir_inicio(struct No* lista, int v) {
    struct No* novo = (struct No*) malloc(sizeof(struct No));
    novo->valor = v;
    novo->prox = lista;
    return novo;
}

Fun√ß√£o para imprimir:
void imprimir(struct No* lista) {
    while (lista != NULL) {
        printf("%d -> ", lista->valor);
        lista = lista->prox;
    }
    printf("NULL\n");
}

3. Lista Duplamente Encadeada

Cada n√≥ possui tr√™s campos: valor, ponteiro para o anterior e ponteiro para o pr√≥ximo.

struct No {
    int valor;
    struct No* ant;
    struct No* prox;
};

Vantagem: √© poss√≠vel navegar tanto para frente quanto para tr√°s na lista.

4. Lista Circular

Na lista circular, o √∫ltimo n√≥ aponta para o primeiro. Pode ser:
- Simples: apenas pr√≥ximo
- Dupla: anterior e pr√≥ximo

Usada em aplica√ß√µes que precisam de percursos cont√≠nuos, como playlists, jogos ou sistemas rotativos.

5. Diferen√ßa entre as Listas

| Tipo de Lista           | Ponteiros usados        | Dire√ß√£o de Navega√ß√£o |
|-------------------------|-------------------------|----------------------|
| Simples Encadeada       | Apenas pr√≥ximo          | Frente               |
| Duplamente Encadeada    | Anterior e pr√≥ximo      | Frente e tr√°s        |
| Circular Simples        | Apenas pr√≥ximo          | Circular             |
| Circular Duplamente Enc.| Anterior e pr√≥ximo      | Circular nos dois    |

---

QUEST√ïES FREQUENTES ‚Äì ESTILO PROVA

1. O que √© uma lista din√¢mica?
- Uma estrutura de dados composta por n√≥s ligados por ponteiros, com aloca√ß√£o din√¢mica.

2. Qual a principal vantagem da lista sobre o vetor?
- Tamanho flex√≠vel e inser√ß√£o/remo√ß√£o sem necessidade de realocar a estrutura.

3. Como detectar o fim de uma lista encadeada simples?
- Quando o ponteiro prox de um n√≥ for igual a NULL.

4. Qual a diferen√ßa entre lista simples e lista duplamente encadeada?
- A lista simples s√≥ aponta para frente; a duplamente encadeada aponta para frente e para tr√°s.

5. Para que serve uma lista circular?
- Para navegar indefinidamente por elementos, reiniciando do come√ßo ao fim automaticamente.

6. Como √© representado um n√≥ de lista encadeada em C?
  struct No {
      int valor;
      struct No* prox;
  };

7. Como inserir um n√≥ no in√≠cio da lista?
  novo->prox = lista;
  lista = novo;</pre>
<h2 id="unidade4">Unidade 4 ‚Äì Grafos</h2>
<pre>Resumo ‚Äì Unidade 4: Grafos

1. O que s√£o Grafos?

Grafos s√£o estruturas matem√°ticas utilizadas para representar rela√ß√µes entre objetos.
Um grafo √© composto por:
- V√©rtices (ou n√≥s): os pontos
- Arestas: liga√ß√µes entre os pontos

Exemplo real: mapa de cidades (v√©rtices) ligadas por estradas (arestas).

2. Aplica√ß√µes de Grafos

- Mapas e rotas (GPS)
- Redes sociais
- Redes de computadores
- Sistemas de recomenda√ß√£o

3. Representa√ß√£o de Grafos em Computadores

Existem duas formas principais de representar grafos:

a) Matriz de Adjac√™ncia:
- Usa uma matriz quadrada.
- Se grafo[i][j] == 1, ent√£o existe aresta de i para j.

Exemplo:
grafo[0][2] = 1; // existe liga√ß√£o do v√©rtice 0 para o 2

Vantagem: acesso direto (tempo constante)
Desvantagem: ocupa muito espa√ßo para grafos esparsos

b) Lista de Adjac√™ncia:
- Usa vetor de listas. Cada posi√ß√£o do vetor representa um v√©rtice e cont√©m uma lista com os vizinhos.

Exemplo em C:
struct No {
    int vertice;
    struct No* prox;
};

struct ListaAdj {
    struct No* inicio;
};

Vantagem: ocupa menos mem√≥ria para grafos com poucas conex√µes

4. Tipos de Grafos

- N√£o dirigido: arestas sem dire√ß√£o (ex: amizades)
- Dirigido: arestas com dire√ß√£o (ex: seguidores)
- Ponderado: cada aresta tem um peso (ex: dist√¢ncia, custo)

5. Implementa√ß√£o B√°sica em C

Representa√ß√£o com matriz:
#define TAM 5
int grafo[TAM][TAM] = {0};

grafo[0][1] = 1;
grafo[1][2] = 1;

Representa√ß√£o com lista:
struct No* lista[TAM];

Adicionar vizinho:
void adicionar_aresta(int origem, int destino) {
    struct No* novo = malloc(sizeof(struct No));
    novo->vertice = destino;
    novo->prox = lista[origem];
    lista[origem] = novo;
}

---

QUEST√ïES FREQUENTES ‚Äì ESTILO PROVA

1. O que √© um grafo?
- Estrutura composta por v√©rtices e arestas, usada para representar rela√ß√µes.

2. Diferen√ßa entre grafo dirigido e n√£o dirigido?
- No grafo dirigido, as conex√µes t√™m dire√ß√£o (A ‚Üí B). No n√£o dirigido, s√£o bidirecionais (A ‚Äî B).

3. Quando usar matriz de adjac√™ncia?
- Quando o grafo for pequeno ou denso (muitas liga√ß√µes).

4. Qual a vantagem da lista de adjac√™ncia?
- Ocupa menos espa√ßo em grafos com poucas conex√µes.

5. O que significa uma aresta ponderada?
- Uma aresta que possui um peso (ex: tempo, custo, dist√¢ncia).

6. Como saber se h√° uma liga√ß√£o entre dois v√©rtices usando matriz?
- Verificar se grafo[i][j] == 1.

7. O que representa lista[i] em uma lista de adjac√™ncia?
- Lista de v√©rtices vizinhos ao v√©rtice i.</pre>
<h2 id="unidade5">Unidade 5 ‚Äì Busca em Grafos</h2>
<pre>Resumo ‚Äì Unidade 5: Busca em Grafos

1. Introdu√ß√£o

Buscar em grafos significa visitar v√©rtices de forma sistem√°tica para encontrar caminhos, componentes, ciclos, entre outros.
Existem dois algoritmos cl√°ssicos para isso:
- Busca em Largura (BFS)
- Busca em Profundidade (DFS)

Al√©m disso, estudamos o Algoritmo de Dijkstra, usado para encontrar o menor caminho.

2. Busca em Profundidade (DFS)

A DFS (Depth-First Search) explora um caminho at√© o fim antes de voltar.

Exemplo de implementa√ß√£o em C:
void dfs(int v, int visitado[], int grafo[TAM][TAM]) {
    visitado[v] = 1;
    printf("%d ", v);
    for (int i = 0; i < TAM; i++) {
        if (grafo[v][i] == 1 && !visitado[i]) {
            dfs(i, visitado, grafo);
        }
    }
}

Aplica√ß√£o: verificar conectividade, encontrar componentes.

3. Busca em Largura (BFS)

A BFS (Breadth-First Search) visita os vizinhos antes de aprofundar.

Exemplo de implementa√ß√£o:
void bfs(int inicio, int grafo[TAM][TAM]) {
    int fila[TAM], visitado[TAM] = {0};
    int ini = 0, fim = 0;

    fila[fim++] = inicio;
    visitado[inicio] = 1;

    while (ini < fim) {
        int atual = fila[ini++];
        printf("%d ", atual);
        for (int i = 0; i < TAM; i++) {
            if (grafo[atual][i] == 1 && !visitado[i]) {
                fila[fim++] = i;
                visitado[i] = 1;
            }
        }
    }
}

Aplica√ß√£o: encontrar o menor n√∫mero de arestas at√© um destino, navega√ß√£o por n√≠veis.

4. Algoritmo de Dijkstra

Usado para encontrar o menor caminho entre dois v√©rtices em grafos com pesos positivos.

Exemplo b√°sico:
- Inicializa dist√¢ncias como infinito, exceto a origem (zero).
- Usa um conjunto de v√©rtices visitados.
- Atualiza as dist√¢ncias dos vizinhos com base no menor caminho encontrado.

Pseudo-c√≥digo:
dist[i] = INFINITO;
dist[origem] = 0;

Para cada vizinho:
    se dist[vizinho] > dist[atual] + peso:
        dist[vizinho] = dist[atual] + peso;

Aplica√ß√µes: GPS, redes, sistemas de transporte.

---

QUEST√ïES FREQUENTES ‚Äì ESTILO PROVA

1. Para que serve a busca em profundidade (DFS)?
- Explorar caminhos profundos, identificar componentes conectados, detectar ciclos.

2. Para que serve a busca em largura (BFS)?
- Explorar grafos em camadas, encontrar caminhos m√≠nimos em n√∫mero de arestas.

3. Qual estrutura de dados √© usada na BFS?
- Fila (queue)

4. Qual estrutura de dados √© usada na DFS?
- Pilha (pode ser recursiva)

5. Qual a principal fun√ß√£o do algoritmo de Dijkstra?
- Encontrar o menor caminho entre um v√©rtice de origem e todos os outros.

6. O Dijkstra funciona com arestas negativas?
- N√£o. Apenas com pesos positivos.

7. Qual a diferen√ßa entre BFS e Dijkstra?
- BFS funciona bem em grafos n√£o ponderados. Dijkstra √© para grafos ponderados.</pre>
</body></html>